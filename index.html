<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aplicación de Flash Cards</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Este script es el marcador para los datos incrustados al exportar -->
    <script id="embedded-data" type="application/json"></script>
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            overscroll-behavior-y: contain;
            background-color: #f4f7f9; /* Color de fondo base, muy suave para la vista */
            background-image: 
                linear-gradient(rgba(193, 200, 217, 0.4) 1px, transparent 1px),
                linear-gradient(to right, rgba(193, 200, 217, 0.4) 1px, transparent 1px);
            background-size: 24px 24px;
        }
        .card {
            perspective: 1500px;
        }
        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.7s;
            transform-style: preserve-3d;
        }
        .card.flipped .card-inner {
            transform: rotateY(180deg);
        }
        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            text-align: center;
            border-radius: 1rem;
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
        }
        .card-front {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        }
        .card-back {
            background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
            transform: rotateY(180deg);
        }
        #front-content {
            text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
        }
        #back-content {
            color: #1e3a8a;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.3);
        }
        .btn-glam {
            transition: all 0.3s ease;
        }
        .btn-glam:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 10px 20px -10px rgba(0, 0, 0, 0.3);
        }
        .deck-active {
            background-color: #e0e7ff;
            color: #4338ca;
            font-weight: 600;
            border-left: 4px solid #6366f1;
            padding-left: calc(0.75rem - 4px);
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(15px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.6s ease-out forwards;
        }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #e5e7eb; }
        ::-webkit-scrollbar-thumb { background: #a5b4fc; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #818cf8; }

        @keyframes pulse-glow {
            0%, 100% {
                color: #64748b; /* slate-500 */
                text-shadow: 0 0 5px rgba(100, 116, 139, 0.2);
            }
            50% {
                color: #4f46e5; /* indigo-600 */
                text-shadow: 0 0 15px rgba(79, 70, 229, 0.5);
            }
        }
        #creator-credit {
            animation: pulse-glow 5s ease-in-out infinite;
        }
    </style>
</head>
<body class="text-slate-800">

    <div id="creator-credit" class="fixed top-4 right-4 text-xs font-semibold z-10">
        by: u3lsam
    </div>

    <div class="min-h-screen grid md:grid-cols-3 lg:grid-cols-4 gap-8 p-4 md:p-8">
        
        <aside class="md:col-span-1 lg:col-span-1 bg-white/70 backdrop-blur-xl border border-white/30 p-6 rounded-2xl shadow-lg flex flex-col gap-8 fade-in">
            <div>
                <h1 class="text-3xl font-bold text-slate-900 bg-clip-text text-transparent bg-gradient-to-r from-violet-600 to-indigo-600">Flash Cards Pro</h1>
                <p class="text-sm text-slate-600 mt-1">El futuro del aprendizaje, hoy.</p>
            </div>

            <div class="space-y-3">
                <h2 class="text-lg font-semibold text-slate-700">Crear Nuevo Mazo</h2>
                <input type="text" id="deckNameInput" placeholder="Ej: Vocabulary Unit 5" class="w-full p-2 bg-white/80 border border-slate-300 rounded-md focus:ring-2 focus:ring-violet-500 focus:border-violet-500 transition">
                <button id="addDeckBtn" class="w-full text-white font-bold py-2.5 px-4 rounded-lg shadow-md bg-gradient-to-r from-violet-500 to-fuchsia-500 btn-glam">
                    Añadir Mazo
                </button>
            </div>

            <div class="space-y-3">
                <h2 class="text-lg font-semibold text-slate-700">Añadir Nueva Tarjeta</h2>
                <textarea id="cardFrontInput" rows="3" placeholder="Palabra en inglés (Ej: 'Apple')" class="w-full p-2 bg-white/80 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"></textarea>
                <textarea id="cardBackInput" rows="3" placeholder="Traducción o definición (Ej: 'Manzana')" class="w-full p-2 bg-white/80 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"></textarea>
                <button id="addCardBtn" class="w-full text-white font-bold py-2.5 px-4 rounded-lg shadow-md bg-gradient-to-r from-sky-500 to-indigo-500 btn-glam">
                    Añadir Tarjeta
                </button>
            </div>

            <div class="space-y-3 pt-4 border-t border-slate-200/80">
                <h2 class="text-lg font-semibold text-slate-700">Gestionar Datos</h2>
                <button id="exportBtn" class="w-full text-white font-bold py-2 px-4 rounded-lg shadow-sm bg-gradient-to-r from-emerald-500 to-teal-500 btn-glam">
                    Exportar como Archivo HTML
                </button>
            </div>
            
            <div class="flex-grow flex flex-col min-h-0">
                 <h2 class="text-lg font-semibold text-slate-700 mb-3">Mis Mazos</h2>
                 <div id="deckList" class="flex-grow overflow-y-auto space-y-2 pr-2">
                 </div>
            </div>
        </aside>

        <main class="md:col-span-2 lg:col-span-3 flex flex-col items-center justify-center p-6 bg-white/70 backdrop-blur-xl border border-white/30 rounded-2xl shadow-lg fade-in" style="animation-delay: 0.1s;">
            <div id="card-viewer" class="w-full max-w-2xl mx-auto flex flex-col items-center">
                <div id="viewer-header" class="mb-4 text-center">
                    <h2 id="currentDeckName" class="text-3xl font-bold">Selecciona o crea un mazo</h2>
                    <p id="cardCounter" class="text-slate-500 font-medium"></p>
                </div>

                <div id="card-container" class="card w-full h-80 mb-6 touch-none">
                    <div id="card-inner" class="card-inner">
                        <div class="card-front">
                            <p id="front-content" class="text-3xl md:text-4xl font-bold text-slate-700 px-12"></p>
                            <div id="card-actions" class="absolute bottom-4 right-4 flex gap-2 hidden">
                                <button id="editCardBtn" class="p-3 rounded-full bg-white/50 hover:bg-white/80 transition-colors shadow-md" title="Editar Tarjeta">
                                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"></path><path d="m15 5 4 4"></path></svg>
                                </button>
                                <button id="speakSlowBtn" class="p-3 rounded-full bg-white/50 hover:bg-white/80 transition-colors shadow-md" title="Escuchar Lento">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-700"><path d="M2 18a4 4 0 0 1 4-4h12a4 4 0 0 1 4 4v0a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4Z"></path><path d="M18 13V8c0-2.5-2-4-4-4-1 0-2 .5-2.5 1"></path><path d="M11.5 13H6"></path><path d="M10 2v2"></path><path d="M6 2v2"></path></svg>
                                </button>
                                <button id="speakNativeBtn" class="p-3 rounded-full bg-white/50 hover:bg-white/80 transition-colors shadow-md" title="Escuchar Nativo">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-700" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <div class="card-back">
                            <p id="back-content" class="text-3xl md:text-4xl font-bold"></p>
                        </div>
                    </div>
                </div>

                <div class="w-full max-w-lg">
                    <div id="nav-controls" class="flex items-center justify-center gap-4 h-14">
                        <button id="flipBtn" class="w-full px-8 py-4 bg-gradient-to-r from-blue-500 to-cyan-500 text-white rounded-xl hover:from-blue-600 hover:to-cyan-600 transition-colors font-bold text-lg shadow-lg btn-glam">Voltear</button>
                    </div>
                     <div id="answer-controls" class="flex flex-wrap justify-center items-center gap-3 hidden">
                        <button id="againBtn" class="flex-grow px-4 py-3 bg-rose-500 text-white rounded-lg hover:bg-rose-600 font-semibold shadow-md btn-glam">Otra vez</button>
                        <button id="hardBtn" class="flex-grow px-4 py-3 bg-orange-500 text-white rounded-lg hover:bg-orange-600 font-semibold shadow-md btn-glam">Difícil</button>
                        <button id="goodBtn" class="flex-grow px-4 py-3 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 font-semibold shadow-md btn-glam">Bien</button>
                        <button id="easyBtn" class="flex-grow px-4 py-3 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 font-semibold shadow-md btn-glam">Fácil</button>
                    </div>
                </div>

                <div id="gesture-hint" class="mt-6 text-center text-slate-400 text-sm hidden md:hidden">
                    <p><strong>Gestos:</strong> Desliza para voltear. Arriba para acertar, abajo para fallar.</p>
                </div>
            </div>
             <div id="empty-state" class="text-center hidden">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
                    <path vector-effect="non-scaling-stroke" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z" />
                </svg>
                <h3 class="mt-2 text-sm font-semibold text-gray-900">No hay tarjetas en este mazo</h3>
                <p class="mt-1 text-sm text-gray-500">Empieza añadiendo una nueva tarjeta en el panel de la izquierda.</p>
            </div>
             <div id="review-summary" class="text-center hidden w-full max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold mb-6 text-slate-800">Resumen de la Sesión</h2>
                <div class="grid md:grid-cols-2 gap-8 items-center bg-slate-50 p-6 rounded-xl mb-6">
                    <div class="relative w-48 h-48 mx-auto">
                        <svg class="w-full h-full" viewBox="0 0 36 36" transform="rotate(-90)">
                            <path class="text-slate-200"
                                d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                                fill="none" stroke="currentColor" stroke-width="3.5" />
                            <path id="summary-circle" class="text-green-500"
                                stroke-linecap="round"
                                d="M18 2.0845 a 15.9155 15.9155 0 0 1 0 31.831 a 15.9155 15.9155 0 0 1 0 -31.831"
                                fill="none" stroke="currentColor" stroke-width="3.5"
                                stroke-dasharray="100, 100"
                                stroke-dashoffset="100"
                                style="transition: stroke-dashoffset 1s ease-out;" />
                        </svg>
                        <div id="summary-percentage" class="absolute inset-0 flex items-center justify-center text-4xl font-bold text-slate-700" style="transform: rotate(90deg);">0%</div>
                    </div>
                    <div class="space-y-4 text-left">
                         <div>
                            <p class="text-sm font-medium text-slate-500">TASA DE ÉXITO</p>
                            <p id="stat-rate" class="text-2xl font-bold text-green-600">0%</p>
                        </div>
                         <div>
                            <p class="text-sm font-medium text-slate-500">TARJETAS REVISADAS</p>
                            <p id="stat-reviewed" class="text-2xl font-bold text-slate-700">0</p>
                        </div>
                         <div>
                            <p class="text-sm font-medium text-slate-500">RESPUESTAS INCORRECTAS</p>
                            <p id="stat-incorrect" class="text-2xl font-bold text-red-600">0</p>
                        </div>
                    </div>
                </div>
                <div id="advice-box" class="bg-indigo-50 p-4 rounded-lg mb-6 text-indigo-800 text-left">
                     <h3 class="font-semibold mb-1">Consejo de Estudio</h3>
                     <p id="advice-text" class="text-sm"></p>
                </div>
        
                <h3 class="text-xl font-bold mb-2 text-slate-700 text-left">Tarjetas para Repasar</h3>
                <div id="incorrect-list" class="text-left mb-6 space-y-2 max-h-48 overflow-y-auto bg-slate-50 p-4 rounded-lg">
                </div>
        
                <div class="flex flex-wrap justify-center gap-4">
                    <button id="start-review-btn" class="px-8 py-3 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 font-bold shadow-md btn-glam">Repasar Incorrectas</button>
                    <button id="restart-deck-btn" class="px-8 py-3 bg-slate-200 rounded-lg hover:bg-slate-300 font-semibold shadow-sm btn-glam">Volver al Mazo</button>
                </div>
            </div>
        </main>
    </div>

    <!-- Edit Modal -->
    <div id="edit-modal" class="fixed inset-0 bg-slate-900/50 backdrop-blur-sm flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-2xl shadow-xl p-6 w-full max-w-md">
            <h2 class="text-2xl font-bold text-slate-800 mb-4">Editar Tarjeta</h2>
            <div class="space-y-4">
                <div>
                    <label for="editCardFrontInput" class="block text-sm font-medium text-slate-600 mb-1">Frente de la tarjeta</label>
                    <textarea id="editCardFrontInput" rows="4" class="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"></textarea>
                </div>
                <div>
                    <label for="editCardBackInput" class="block text-sm font-medium text-slate-600 mb-1">Dorso de la tarjeta</label>
                    <textarea id="editCardBackInput" rows="4" class="w-full p-2 border border-slate-300 rounded-md focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition"></textarea>
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="cancelEditBtn" class="px-4 py-2 bg-slate-200 rounded-lg hover:bg-slate-300 font-semibold shadow-sm btn-glam">Cancelar</button>
                <button id="saveEditBtn" class="px-4 py-2 bg-indigo-500 text-white rounded-lg hover:bg-indigo-600 font-bold shadow-md btn-glam">Guardar Cambios</button>
            </div>
        </div>
    </div>

    <div id="notification" class="fixed bottom-5 right-5 bg-slate-900 text-white py-3 px-5 rounded-lg shadow-xl opacity-0 translate-y-8 transition-all duration-300 ease-in-out border-t-2 border-cyan-400">
        <p id="notification-message"></p>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const deckNameInput = document.getElementById('deckNameInput');
            const addDeckBtn = document.getElementById('addDeckBtn');
            const cardFrontInput = document.getElementById('cardFrontInput');
            const cardBackInput = document.getElementById('cardBackInput');
            const addCardBtn = document.getElementById('addCardBtn');
            const deckList = document.getElementById('deckList');
            const currentDeckName = document.getElementById('currentDeckName');
            const cardCounter = document.getElementById('cardCounter');
            const cardContainer = document.getElementById('card-container');
            const frontContent = document.getElementById('front-content');
            const backContent = document.getElementById('back-content');
            const flipBtn = document.getElementById('flipBtn');
            const cardViewer = document.getElementById('card-viewer');
            const emptyState = document.getElementById('empty-state');
            const exportBtn = document.getElementById('exportBtn');
            const notification = document.getElementById('notification');
            const notificationMessage = document.getElementById('notification-message');
            const navControls = document.getElementById('nav-controls');
            const answerControls = document.getElementById('answer-controls');
            const reviewSummary = document.getElementById('review-summary');
            const summaryPercentage = document.getElementById('summary-percentage');
            const summaryCircle = document.getElementById('summary-circle');
            const statRate = document.getElementById('stat-rate');
            const statReviewed = document.getElementById('stat-reviewed');
            const statIncorrect = document.getElementById('stat-incorrect');
            const adviceText = document.getElementById('advice-text');
            const incorrectList = document.getElementById('incorrect-list');
            const startReviewBtn = document.getElementById('start-review-btn');
            const restartDeckBtn = document.getElementById('restart-deck-btn');
            const gestureHint = document.getElementById('gesture-hint');
            const againBtn = document.getElementById('againBtn');
            const hardBtn = document.getElementById('hardBtn');
            const goodBtn = document.getElementById('goodBtn');
            const easyBtn = document.getElementById('easyBtn');
            const cardActions = document.getElementById('card-actions');
            const speakSlowBtn = document.getElementById('speakSlowBtn');
            const speakNativeBtn = document.getElementById('speakNativeBtn');
            const editCardBtn = document.getElementById('editCardBtn');
            const editModal = document.getElementById('edit-modal');
            const editCardFrontInput = document.getElementById('editCardFrontInput');
            const editCardBackInput = document.getElementById('editCardBackInput');
            const saveEditBtn = document.getElementById('saveEditBtn');
            const cancelEditBtn = document.getElementById('cancelEditBtn');

            let decks = [];
            let currentDeckIndex = -1;
            let currentCardIndex = 0;
            let isFlipped = false;
            let notificationTimeout;
            let sessionReviewedIndices = new Set();
            let sessionIncorrectIndices = [];
            let isReviewingIncorrect = false;
            let cardsForReview = [];
            let touchStartX = 0;
            let touchStartY = 0;
            let voices = [];
            let isLoadedFromExport = false;
            let editingCardInfo = null;

            const saveData = () => {
                if (isLoadedFromExport) {
                    return;
                }
                localStorage.setItem('flashCardDecks', JSON.stringify(decks));
            };

            const loadData = () => {
                const embeddedDataElement = document.getElementById('embedded-data');
                
                if (embeddedDataElement && embeddedDataElement.textContent.trim().length > 2) {
                    try {
                        const embeddedDecks = JSON.parse(embeddedDataElement.textContent);
                        if (Array.isArray(embeddedDecks)) {
                            decks = embeddedDecks;
                            if (decks.length > 0) currentDeckIndex = 0;
                            isLoadedFromExport = true;
                            showNotification('Mazos cargados desde el archivo exportado.');
                            return;
                        }
                    } catch (e) {
                        console.error("Error al analizar los datos incrustados.", e);
                    }
                }
                
                const savedDecks = localStorage.getItem('flashCardDecks');
                if (savedDecks) {
                    try {
                        decks = JSON.parse(savedDecks);
                        if (decks.length > 0) currentDeckIndex = 0;
                    } catch (e) {
                        console.error("Error al analizar datos de localStorage.", e);
                        decks = [];
                    }
                }
            };

            const renderDecks = () => {
                deckList.innerHTML = '';
                decks.forEach((deck, index) => {
                    const deckElement = document.createElement('div');
                    deckElement.className = `p-3 rounded-md cursor-pointer transition-all duration-200 ${index === currentDeckIndex ? 'deck-active' : 'hover:bg-slate-100'}`;
                    deckElement.textContent = deck.name;
                    deckElement.addEventListener('click', () => selectDeck(index));
                    deckList.appendChild(deckElement);
                });
            };

            const renderCard = () => {
                navControls.classList.remove('hidden');
                answerControls.classList.add('hidden');
                
                if (isFlipped) {
                    cardContainer.classList.add('flipped');
                    navControls.classList.add('hidden');
                    answerControls.classList.remove('hidden');
                } else {
                    cardContainer.classList.remove('flipped');
                }

                if (currentDeckIndex === -1 || decks.length === 0) {
                    currentDeckName.textContent = 'Selecciona o crea un mazo';
                    cardCounter.textContent = '';
                    frontContent.textContent = 'Empieza a aprender';
                    backContent.textContent = '';
                    cardViewer.classList.remove('hidden');
                    emptyState.classList.add('hidden');
                    reviewSummary.classList.add('hidden');
                    gestureHint.classList.add('hidden');
                    cardActions.classList.add('hidden');
                    return;
                }

                const deck = decks[currentDeckIndex];
                currentDeckName.textContent = deck.name;
                
                const cardSource = isReviewingIncorrect ? cardsForReview : deck.cards;

                if (cardSource.length === 0) {
                    cardViewer.classList.add('hidden');
                    emptyState.classList.remove('hidden');
                    reviewSummary.classList.add('hidden');
                    gestureHint.classList.add('hidden');
                    cardActions.classList.add('hidden');
                    cardCounter.textContent = isReviewingIncorrect ? '' : '0 / 0';
                } else {
                    cardViewer.classList.remove('hidden');
                    emptyState.classList.add('hidden');
                    reviewSummary.classList.add('hidden');
                    gestureHint.classList.remove('hidden');
                    cardActions.classList.remove('hidden');
                    
                    const card = cardSource[currentCardIndex];
                    frontContent.textContent = card.front;
                    backContent.textContent = card.back;
                    cardCounter.textContent = `${currentCardIndex + 1} / ${cardSource.length}`;
                }
            };
            
            const populateVoiceList = () => {
                if (typeof speechSynthesis === 'undefined') return;
                voices = speechSynthesis.getVoices();
                if (voices.length === 0) {
                    speechSynthesis.addEventListener('voiceschanged', populateVoiceList);
                }
            };

            const speakText = (text, rate = 1.0) => {
                if ('speechSynthesis' in window) {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(text);
                    
                    let selectedVoice = voices.find(voice => voice.name === 'Google US English');
                    if (!selectedVoice) {
                        selectedVoice = voices.find(voice => voice.lang === 'en-US');
                    }
                    if (!selectedVoice) {
                        selectedVoice = voices.find(voice => voice.lang.startsWith('en-'));
                    }
                    
                    if (selectedVoice) {
                        utterance.voice = selectedVoice;
                    } else {
                        utterance.lang = 'en-US';
                    }
                    
                    utterance.rate = rate;
                    window.speechSynthesis.speak(utterance);
                } else {
                    showNotification('Tu navegador no soporta la síntesis de voz.');
                }
            };

            const shuffleArray = (array) => {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            };
            
            const showNotification = (message, duration = 3000) => {
                notificationMessage.textContent = message;
                notification.classList.remove('opacity-0', 'translate-y-8');
                
                clearTimeout(notificationTimeout);
                notificationTimeout = setTimeout(() => {
                    notification.classList.add('opacity-0', 'translate-y-8');
                }, duration);
            };
            
            const resetSession = () => {
                sessionReviewedIndices.clear();
                sessionIncorrectIndices = [];
                isReviewingIncorrect = false;
                cardsForReview = [];
            }

            const addDeck = () => {
                const name = deckNameInput.value.trim();
                if (name) {
                    decks.push({ name: name, cards: [] });
                    deckNameInput.value = '';
                    currentDeckIndex = decks.length - 1;
                    isLoadedFromExport = false; 
                    saveData();
                    renderAll();
                    resetSession();
                }
            };

            const selectDeck = (index) => {
                if (currentDeckIndex === index) return;
                currentDeckIndex = index;
                
                if (decks[currentDeckIndex] && decks[currentDeckIndex].cards.length > 0) {
                    shuffleArray(decks[currentDeckIndex].cards);
                }

                currentCardIndex = 0;
                isFlipped = false;
                resetSession();
                renderAll();
            };

            const addCard = () => {
                if (currentDeckIndex === -1) {
                    showNotification('Por favor, selecciona o crea un mazo primero.');
                    return;
                }
                const front = cardFrontInput.value.trim();
                const back = cardBackInput.value.trim();
                if (front && back) {
                    decks[currentDeckIndex].cards.push({ front, back });
                    cardFrontInput.value = '';
                    cardBackInput.value = '';
                    currentCardIndex = decks[currentDeckIndex].cards.length - 1;
                    isFlipped = false;
                    isLoadedFromExport = false; 
                    resetSession();
                    saveData();
                    renderAll();
                }
            };

            const exportDecks = () => {
                if (decks.length === 0) {
                    showNotification('No hay mazos para exportar.');
                    return;
                }
                
                const doc = document.cloneNode(true);
                const currentData = JSON.stringify(decks);
                doc.getElementById('embedded-data').textContent = currentData;
                
                const finalHtml = `<!DOCTYPE html>\n${doc.documentElement.outerHTML}`;

                const dataBlob = new Blob([finalHtml], { type: "text/html" });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                const deckName = decks[currentDeckIndex] ? decks[currentDeckIndex].name.replace(/[^a-z0-9]/gi, '_').toLowerCase() : 'mazos';
                link.download = `flashcards_${deckName}.html`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                showNotification('Aplicación con mazos exportada como .html');
            };

            const handleAnswer = (isCorrect) => {
                if (isReviewingIncorrect) {
                    if (isCorrect) {
                        cardsForReview.splice(currentCardIndex, 1);
                        if (currentCardIndex >= cardsForReview.length) {
                             currentCardIndex = Math.max(0, cardsForReview.length - 1);
                        }
                    }
                    if(cardsForReview.length === 0) {
                        showNotification("¡Felicidades! Repasaste todas las tarjetas.");
                        restartDeck();
                    } else {
                        if(currentCardIndex >= cardsForReview.length) currentCardIndex = 0;
                        isFlipped = false;
                        renderCard();
                    }
                    return;
                }
                
                const cardText = frontContent.textContent;
                const originalCardIndex = decks[currentDeckIndex].cards.findIndex(c => c.front === cardText);
                if (!isCorrect) {
                    if(originalCardIndex !== -1) sessionIncorrectIndices.push(originalCardIndex);
                }
                if(originalCardIndex !== -1) sessionReviewedIndices.add(originalCardIndex);

                const sessionSize = 10;
                const deckSize = decks[currentDeckIndex].cards.length;

                if (sessionReviewedIndices.size >= Math.min(sessionSize, deckSize)) {
                    showReviewSummary();
                } else {
                    nextCard(); 
                }
            };

            const showReviewSummary = () => {
                cardViewer.classList.add('hidden');
                reviewSummary.classList.remove('hidden');
                gestureHint.classList.add('hidden');
                cardActions.classList.add('hidden');

                const totalReviewed = sessionReviewedIndices.size;
                const uniqueIncorrectIndices = [...new Set(sessionIncorrectIndices)];
                const totalIncorrect = uniqueIncorrectIndices.length;
                const totalCorrect = totalReviewed - totalIncorrect;
                const successRate = totalReviewed > 0 ? Math.max(0, (totalCorrect / totalReviewed) * 100) : 0;

                summaryPercentage.textContent = `${Math.round(successRate)}%`;
                statRate.textContent = `${Math.round(successRate)}%`;
                statReviewed.textContent = totalReviewed;
                statIncorrect.textContent = totalIncorrect;

                setTimeout(() => {
                    summaryCircle.style.strokeDashoffset = 100 - successRate;
                    if (successRate < 50) {
                        summaryCircle.className.baseVal = 'text-red-500';
                        statRate.className = 'text-2xl font-bold text-red-600';
                    } else if (successRate < 80) {
                        summaryCircle.className.baseVal = 'text-amber-500';
                        statRate.className = 'text-2xl font-bold text-amber-600';
                    } else {
                        summaryCircle.className.baseVal = 'text-green-500';
                        statRate.className = 'text-2xl font-bold text-green-600';
                    }
                }, 100);
                
                 if (successRate >= 95) {
                    adviceText.textContent = "¡Dominio total! Estás listo para material nuevo o un repaso más espaciado. Sigue así.";
                } else if (successRate >= 80) {
                    adviceText.textContent = "¡Excelente trabajo! Has entendido la mayor parte del material. Un repaso rápido a las tarjetas incorrectas te ayudará a alcanzar la perfección.";
                } else if (successRate >= 50) {
                    adviceText.textContent = "¡Buen progreso! Estás construyendo una base sólida. Enfócate en repasar las tarjetas que fallaste para afianzar esos conceptos.";
                } else {
                    adviceText.textContent = "No te desanimes, ¡la práctica hace al maestro! Considera dividir el mazo en partes más pequeñas y repasa con más frecuencia.";
                }

                incorrectList.innerHTML = '';
                if(totalIncorrect > 0) {
                    startReviewBtn.classList.remove('hidden');
                    uniqueIncorrectIndices.forEach(index => {
                        const card = decks[currentDeckIndex].cards[index];
                        const li = document.createElement('li');
                        li.className = "p-2 bg-slate-100 rounded";
                        li.innerHTML = `<span class="font-semibold">${card.front}</span> <span class="text-slate-500">/ ${card.back}</span>`;
                        incorrectList.appendChild(li);
                    });
                } else {
                    incorrectList.innerHTML = '<p class="text-slate-500">¡Ninguna tarjeta incorrecta en esta sesión!</p>';
                    startReviewBtn.classList.add('hidden');
                }
            };
            
            const openEditModal = () => {
                const cardSource = isReviewingIncorrect ? cardsForReview : decks[currentDeckIndex].cards;
                const card = cardSource[currentCardIndex];
                if(!card) return;
                
                editingCardInfo = {
                    deckIndex: currentDeckIndex,
                    cardIndex: isReviewingIncorrect ? decks[currentDeckIndex].cards.findIndex(c => c.front === card.front) : currentCardIndex,
                    isReview: isReviewingIncorrect
                };

                editCardFrontInput.value = card.front;
                editCardBackInput.value = card.back;
                editModal.classList.remove('hidden');
            };
            
            const closeEditModal = () => {
                editModal.classList.add('hidden');
                editingCardInfo = null;
            };

            const saveCardChanges = () => {
                if(!editingCardInfo) return;

                const newFront = editCardFrontInput.value.trim();
                const newBack = editCardBackInput.value.trim();

                if (newFront && newBack) {
                    const { deckIndex, cardIndex, isReview } = editingCardInfo;
                    decks[deckIndex].cards[cardIndex].front = newFront;
                    decks[deckIndex].cards[cardIndex].back = newBack;

                    if (isReview) {
                        cardsForReview[currentCardIndex].front = newFront;
                        cardsForReview[currentCardIndex].back = newBack;
                    }

                    isLoadedFromExport = false; // Permitir guardar cambios
                    saveData();
                    renderCard();
                    closeEditModal();
                    showNotification('Tarjeta actualizada con éxito.');
                } else {
                    showNotification('Ambos campos deben tener contenido.');
                }
            };


            const startReview = () => {
                isReviewingIncorrect = true;
                const uniqueIncorrectIndices = [...new Set(sessionIncorrectIndices)];
                cardsForReview = uniqueIncorrectIndices.map(index => ({...decks[currentDeckIndex].cards[index]}));
                currentCardIndex = 0;
                isFlipped = false;
                renderAll();
            };

            const restartDeck = () => {
                if (decks[currentDeckIndex] && decks[currentDeckIndex].cards.length > 0) {
                    shuffleArray(decks[currentDeckIndex].cards);
                }
                resetSession();
                currentCardIndex = 0;
                isFlipped = false;
                renderAll();
            }
            
            const flipCard = () => {
                if (currentDeckIndex === -1 || decks[currentDeckIndex].cards.length === 0) return;
                isFlipped = !isFlipped;
                renderCard();
            };

            const nextCard = () => {
                const cardSource = isReviewingIncorrect ? cardsForReview : decks[currentDeckIndex].cards;
                if (currentDeckIndex === -1 || cardSource.length === 0) return;

                if (currentCardIndex < cardSource.length - 1) {
                    currentCardIndex++;
                } else {
                    currentCardIndex = 0;
                }
                isFlipped = false;
                renderCard();
            };
            
            const handleTouchStart = (e) => {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            };

            const handleTouchEnd = (e) => {
                const touchEndX = e.changedTouches[0].screenX;
                const touchEndY = e.changedTouches[0].screenY;
                handleSwipeGesture(touchEndX, touchEndY);
            };

            const handleSwipeGesture = (touchEndX, touchEndY) => {
                const deltaX = touchEndX - touchStartX;
                const deltaY = touchEndY - touchStartY;
                const swipeThreshold = 50;

                if (Math.abs(deltaY) > swipeThreshold && Math.abs(deltaY) > Math.abs(deltaX)) {
                    if (isFlipped) {
                        if (deltaY < 0) {
                            handleAnswer(true);
                            showNotification('Marcado como "Bien" 👍', 1500);
                        } else {
                            handleAnswer(false);
                            showNotification('Marcado como "Otra vez" 👎', 1500);
                        }
                    }
                } else if (Math.abs(deltaX) > swipeThreshold) {
                    if (!isFlipped) {
                        flipCard();
                    }
                }
            };

            const renderAll = () => {
                renderDecks();
                renderCard();
            };

            addDeckBtn.addEventListener('click', addDeck);
            deckNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') addDeck(); });
            addCardBtn.addEventListener('click', addCard);
            flipBtn.addEventListener('click', flipCard);
            exportBtn.addEventListener('click', exportDecks);
            startReviewBtn.addEventListener('click', startReview);
            restartDeckBtn.addEventListener('click', restartDeck);

            editCardBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                openEditModal();
            });
            cancelEditBtn.addEventListener('click', closeEditModal);
            saveEditBtn.addEventListener('click', saveCardChanges);
            editModal.addEventListener('click', (e) => {
                if (e.target === editModal) {
                    closeEditModal();
                }
            });


            speakSlowBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                speakText(frontContent.textContent, 0.6);
            });

            speakNativeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                speakText(frontContent.textContent, 1.0);
            });

            againBtn.addEventListener('click', () => handleAnswer(false));
            hardBtn.addEventListener('click', () => handleAnswer(false));
            goodBtn.addEventListener('click', () => handleAnswer(true));
            easyBtn.addEventListener('click', () => handleAnswer(true));

            cardContainer.addEventListener('touchstart', handleTouchStart, false);
            cardContainer.addEventListener('touchend', handleTouchEnd, false);

            populateVoiceList();
            loadData();
            if (currentDeckIndex !== -1 && decks[currentDeckIndex] && decks[currentDeckIndex].cards.length > 0) {
                 shuffleArray(decks[currentDeckIndex].cards);
            }
            renderAll();
        });
    </script>
</body>
</html>




